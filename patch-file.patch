diff --git c/.gitignore i/.gitignore
index 58a5bf3..b4342af 100644
--- c/.gitignore
+++ i/.gitignore
@@ -36,6 +36,7 @@ amplify/mock-data
 amplify/mock-api-resources
 amplify/backend/amplify-meta.json
 amplify/backend/.temp
+amplify/backend/function/**/src/**/*.js
 build/
 dist/
 node_modules/
diff --git c/amplify/backend/function/predictionsLambda/src/event.json i/amplify/backend/function/predictionsLambda/event.json
similarity index 86%
rename from amplify/backend/function/predictionsLambda/src/event.json
rename to amplify/backend/function/predictionsLambda/event.json
index dd9390e..521e674 100644
--- c/amplify/backend/function/predictionsLambda/src/event.json
+++ i/amplify/backend/function/predictionsLambda/event.json
@@ -1,6 +1,6 @@
 {
   "httpMethod": "POST",
-  "path": "/predictions/place",
+  "path": "/predictions/close",
   "queryStringParameters": {},
   "headers": {
     "Content-Type": "application/json"
diff --git c/amplify/backend/function/predictionsLambda/lib/app.ts i/amplify/backend/function/predictionsLambda/lib/app.ts
new file mode 100644
index 0000000..fd47ecc
--- /dev/null
+++ i/amplify/backend/function/predictionsLambda/lib/app.ts
@@ -0,0 +1,138 @@
+/*
+Copyright 2017 - 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with the License. A copy of the License is located at
+    http://aws.amazon.com/apache2.0/
+or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and limitations under the License.
+*/
+
+import awsServerlessExpressMiddleware from "aws-serverless-express/middleware";
+import bodyParser from "body-parser";
+import express from "express";
+
+import { Prediction, PredictionAlreadyClosed } from "./models/prediction";
+import { fetchBitcoinPrice } from "./utils/fetchBitcoinPrice.js";
+import { schedulePredictionClosing } from "./utils/schedulePredictionClosing";
+import {
+  User,
+  UserNotFound,
+  PredictionInProgress,
+  InvalidDirection,
+} from "./models/user";
+
+const path = "/predictions";
+
+// declare a new express app
+const app = express();
+app.use(bodyParser.json());
+app.use(awsServerlessExpressMiddleware.eventContext());
+
+// Enable CORS for all methods
+app.use(function (req, res, next) {
+  res.header("Access-Control-Allow-Origin", "*");
+  res.header("Access-Control-Allow-Headers", "*");
+  next();
+});
+
+/************************************
+ * HTTP post method to place a prediction *
+ *************************************/
+
+app.post(path + "/place", async function (req, res) {
+  try {
+    let user: User | null;
+    try {
+      user = await User.findById(req.body.userId);
+    } catch (err) {
+      if (err instanceof UserNotFound) {
+        res.status(404).json({ error: "User not found" });
+        return;
+      }
+      throw err;
+    }
+
+    try {
+      const direction = req.body.direction;
+      const duration = req.body.duration
+        ? Number(req.body.duration)
+        : Prediction.DEFAULT_DURATION_IN_SECONDS;
+      const startPrice = await fetchBitcoinPrice();
+
+      // TODO: Wrap these two async functions with Promise.all and rollback
+      // completed action if other one fails
+      await user.predict(startPrice, direction, duration);
+      console.log("user :", user);
+      const lastPredictionId = user.getLastPrediction().id;
+      await schedulePredictionClosing(user.id, lastPredictionId, duration);
+
+      res.status(200).json(user);
+      return;
+    } catch (err) {
+      if (err instanceof PredictionInProgress) {
+        res.status(400).json({ error: "A prediction is already in progress" });
+        return;
+      } else if (err instanceof InvalidDirection) {
+        res.status(400).json({ error: "Invalid direction provided" });
+        return;
+      } else {
+        throw err;
+      }
+    }
+  } catch (err) {
+    console.error(err);
+    res.status(500).json({ error: "Internal server error" });
+    return;
+  }
+});
+
+/************************************
+ * HTTP post method to close a prediction *
+ *************************************/
+
+app.post(path + "/close", async function (req, res) {
+  try {
+    let user: User;
+    try {
+      user = await User.findById(req.body.userId);
+    } catch (err) {
+      if (err instanceof UserNotFound) {
+        res.status(404).json({ error: "User not found" });
+        return;
+      }
+      throw err;
+    }
+
+    try {
+      const finalPrice = await fetchBitcoinPrice();
+      const lastPrediction = user.getLastPrediction().close(finalPrice);
+
+      await user.closeLastPrediction(lastPrediction);
+
+      res.status(200).json(user);
+      return;
+    } catch (err) {
+      if (err instanceof PredictionAlreadyClosed) {
+        res
+          .status(422)
+          .json({ error: "That prediction has already finished." });
+
+        return;
+      } else if (err instanceof InvalidDirection) {
+        res.status(400).json({ error: "Invalid direction provided" });
+        return;
+      } else {
+        throw err;
+      }
+    }
+  } catch (err) {
+    console.error(err);
+    res.status(500).json({ error: "Internal server error" });
+    return;
+  }
+});
+
+app.listen(3000, function () {
+  console.log("App started");
+});
+
+export { app };
diff --git c/amplify/backend/function/predictionsLambda/lib/index.ts i/amplify/backend/function/predictionsLambda/lib/index.ts
new file mode 100644
index 0000000..e0287ef
--- /dev/null
+++ i/amplify/backend/function/predictionsLambda/lib/index.ts
@@ -0,0 +1,17 @@
+import {
+  APIGatewayProxyEvent,
+  APIGatewayProxyResult,
+  Context,
+} from "aws-lambda";
+import awsServerlessExpress from "aws-serverless-express";
+import { app } from "./app";
+
+const server = awsServerlessExpress.createServer(app);
+
+export const handler = async (
+  event: APIGatewayProxyEvent,
+  context: Context,
+): Promise<APIGatewayProxyResult> => {
+  console.log(`EVENT: ${JSON.stringify(event)}`);
+  return awsServerlessExpress.proxy(server, event, context, "PROMISE").promise;
+};
diff --git c/amplify/backend/function/predictionsLambda/lib/models/prediction.ts i/amplify/backend/function/predictionsLambda/lib/models/prediction.ts
new file mode 100644
index 0000000..f08be5c
--- /dev/null
+++ i/amplify/backend/function/predictionsLambda/lib/models/prediction.ts
@@ -0,0 +1,87 @@
+import crypto from "crypto";
+
+export class PredictionAlreadyClosed extends Error {
+  constructor(message?: string) {
+    super(message);
+    this.name = "PredictionAlreadyClosed";
+  }
+}
+
+export class Prediction {
+  static DEFAULT_DURATION_IN_SECONDS = 60;
+  static DIRECTIONS = { UP: "up", DOWN: "down" };
+  static STATUSES = { WON: "won", LOST: "lost" };
+
+  public direction: string;
+  public startPrice: number;
+  public startTime: number;
+  public finishTime: number;
+  public id?: string;
+  public finalPrice?: number;
+  public status?: string;
+
+  constructor({
+    id,
+    direction,
+    startPrice,
+    finalPrice,
+    startTime,
+    finishTime,
+    status,
+  }: {
+    id?: string;
+    direction: string;
+    startPrice: number;
+    finalPrice?: number;
+    startTime: number;
+    finishTime: number;
+    status?: string;
+  }) {
+    this.id = id ?? crypto.randomUUID();
+    this.direction = direction;
+    this.startTime = startTime;
+    this.finishTime = finishTime;
+    this.startPrice = startPrice;
+    this.finalPrice = finalPrice ?? null;
+    this.status = status ?? null;
+  }
+
+  close(finalPrice: number) {
+    if (this.finalPrice) throw new PredictionAlreadyClosed();
+
+    this.finalPrice = finalPrice;
+
+    if (
+      this.isWinningResult(this.startPrice, this.finalPrice, this.direction)
+    ) {
+      this.status = Prediction.STATUSES.WON;
+    } else {
+      this.status = Prediction.STATUSES.LOST;
+    }
+
+    return this;
+  }
+
+  toJSON() {
+    return {
+      direction: this.direction,
+      startPrice: this.startPrice,
+      startTime: this.startTime,
+      finishTime: this.finishTime,
+      finalPrice: this.finalPrice,
+      status: this.status,
+      id: this.id,
+    };
+  }
+
+  private isWinningResult(
+    startPrice: number,
+    finalPrice: number,
+    direction: string,
+  ) {
+    return (
+      (finalPrice > startPrice && direction == Prediction.DIRECTIONS.UP) ||
+      (startPrice > finalPrice && direction == Prediction.DIRECTIONS.DOWN)
+    );
+  }
+}
diff --git c/amplify/backend/function/predictionsLambda/lib/models/user.ts i/amplify/backend/function/predictionsLambda/lib/models/user.ts
new file mode 100644
index 0000000..e0896b1
--- /dev/null
+++ i/amplify/backend/function/predictionsLambda/lib/models/user.ts
@@ -0,0 +1,127 @@
+import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
+import {
+  DynamoDBDocumentClient,
+  GetCommand,
+  PutCommand,
+} from "@aws-sdk/lib-dynamodb";
+
+import { Prediction } from "./prediction";
+
+const ddbClient = new DynamoDBClient({ region: process.env.REGION });
+const ddbDocClient = DynamoDBDocumentClient.from(ddbClient, {
+  marshallOptions: { convertClassInstanceToMap: true },
+});
+
+let tableName = "usersTable";
+if (process.env.ENV && process.env.ENV !== "NONE") {
+  tableName = tableName + "-" + process.env.ENV;
+}
+
+class UserNotFound extends Error {
+  constructor(message?: string) {
+    super(message);
+    this.name = "UserNotFound";
+  }
+}
+
+class PredictionInProgress extends Error {
+  constructor(message?: string) {
+    super(message);
+    this.name = "PredictionInProgress";
+  }
+}
+
+class InvalidDirection extends Error {
+  constructor(message?: string) {
+    super(message);
+    this.name = "InvalidDirection";
+  }
+}
+
+class User {
+  constructor(
+    public id: string,
+    public predictions: Prediction[],
+    public score?: number,
+  ) {
+    this.id = id || null;
+    this.predictions = predictions;
+    this.score = score ?? 0;
+  }
+
+  getLastPrediction() {
+    return new Prediction(this.predictions[this.predictions.length - 1]);
+  }
+
+  async closeLastPrediction(prediction: Prediction) {
+    if (prediction.status == Prediction.STATUSES.WON) {
+      this.score++;
+    } else {
+      this.score--;
+    }
+
+    this.predictions[this.predictions.length - 1] = prediction;
+
+    return await this.save();
+  }
+
+  static async findById(id: string) {
+    const params = {
+      TableName: tableName,
+      Key: { id },
+    };
+
+    try {
+      const { Item } = await ddbDocClient.send(new GetCommand(params));
+      if (!Item) throw new UserNotFound();
+      return new User(Item.id, Item.predictions, Item.score);
+    } catch (error) {
+      console.error("Error finding user:", error);
+      throw error;
+    }
+  }
+
+  async predict(startPrice: number, direction: string, duration: number) {
+    // If any of the user's predictions don't have a final price, don't allow a new prediction.
+    if (this.predictions.some((prediction) => !prediction.finalPrice)) {
+      throw new PredictionInProgress();
+    }
+
+    // TODO: Move this logic to Prediction class
+    if (!Object.values(Prediction.DIRECTIONS).includes(direction)) {
+      throw new InvalidDirection();
+    }
+
+    const startTime = Date.now();
+    const finishTime =
+      startTime + (duration || Prediction.DEFAULT_DURATION_IN_SECONDS) * 1000;
+
+    const newPrediction = new Prediction({
+      direction: direction,
+      startPrice: startPrice,
+      startTime: startTime,
+      finishTime: finishTime,
+    });
+
+    this.predictions.push(newPrediction);
+    console.log(this);
+    return await this.save();
+  }
+
+  async save() {
+    const params = {
+      TableName: tableName,
+      Item: { ...this },
+    };
+
+    try {
+      await ddbDocClient.send(new PutCommand(params));
+      return this;
+    } catch (error) {
+      console.error("Error saving user:", error);
+      throw error;
+    }
+  }
+}
+
+export { User, UserNotFound, PredictionInProgress, InvalidDirection };
diff --git c/amplify/backend/function/predictionsLambda/lib/utils/fetchBitcoinPrice.ts i/amplify/backend/function/predictionsLambda/lib/utils/fetchBitcoinPrice.ts
new file mode 100644
index 0000000..568939b
--- /dev/null
+++ i/amplify/backend/function/predictionsLambda/lib/utils/fetchBitcoinPrice.ts
@@ -0,0 +1,18 @@
+import axios from "axios";
+
+export const fetchBitcoinPrice = async () => {
+  const API_URL = "https://okx.com/api/v5/market/ticker?instId=BTC-USD-SWAP";
+
+  try {
+    const response = await axios.get(API_URL);
+
+    const bitcoinPriceInCents = Math.round(
+      Number.parseFloat(response.data.data[0].last) * 100,
+    );
+
+    return bitcoinPriceInCents;
+  } catch (err) {
+    console.error("Error fetching Bitcoin price:", err);
+    throw err;
+  }
+};
diff --git c/amplify/backend/function/predictionsLambda/lib/utils/schedulePredictionClosing.ts i/amplify/backend/function/predictionsLambda/lib/utils/schedulePredictionClosing.ts
new file mode 100644
index 0000000..8df136d
--- /dev/null
+++ i/amplify/backend/function/predictionsLambda/lib/utils/schedulePredictionClosing.ts
@@ -0,0 +1,33 @@
+import { SFNClient, StartExecutionCommand } from "@aws-sdk/client-sfn";
+
+// TODO: Fix hardcoded url and arns to handle other envs (staging/prod/etc)
+// TODO: Set retry behavior
+export const schedulePredictionClosing = async (
+  userId: string,
+  predictionId: string,
+  duration: number,
+) => {
+  const response = await new SFNClient().send(
+    new StartExecutionCommand({
+      stateMachineArn:
+        "arn:aws:states:eu-north-1:393809552328:stateMachine:predictionStateMachine",
+      name: `close-prediction-${predictionId}`,
+      input: JSON.stringify({
+        waitSeconds: duration,
+        apiDetails: {
+          url: "https://8f3eziiwfh.execute-api.eu-north-1.amazonaws.com/dev/predictions/close",
+          method: "POST",
+          headers: {
+            "Content-Type": "application/json",
+          },
+          body: {
+            timestamp: new Date().toISOString(),
+            userId: userId,
+          },
+        },
+      }),
+    }),
+  );
+
+  return response;
+};
diff --git c/amplify/backend/function/predictionsLambda/src/package-lock.json i/amplify/backend/function/predictionsLambda/package-lock.json
similarity index 95%
rename from amplify/backend/function/predictionsLambda/src/package-lock.json
rename to amplify/backend/function/predictionsLambda/package-lock.json
index 27ced09..029243d 100644
--- c/amplify/backend/function/predictionsLambda/src/package-lock.json
+++ i/amplify/backend/function/predictionsLambda/package-lock.json
@@ -9,6 +9,7 @@
       "version": "1.0.0",
       "license": "Apache-2.0",
       "dependencies": {
+        "@types/aws-serverless-express": "^3.3.10",
         "aws-serverless-express": "^3.3.5",
         "axios": "^1.8.4",
         "body-parser": "^1.19.1",
@@ -1558,8 +1559,102 @@
     "node_modules/@types/aws-lambda": {
       "version": "8.10.149",
       "resolved": "https://registry.npmjs.org/@types/aws-lambda/-/aws-lambda-8.10.149.tgz",
-      "integrity": "sha512-NXSZIhfJjnXqJgtS7IwutqIF/SOy1Wz5Px4gUY1RWITp3AYTyuJS4xaXr/bIJY1v15XMzrJ5soGnPM+7uigZjA==",
-      "dev": true
+      "integrity": "sha512-NXSZIhfJjnXqJgtS7IwutqIF/SOy1Wz5Px4gUY1RWITp3AYTyuJS4xaXr/bIJY1v15XMzrJ5soGnPM+7uigZjA=="
+    },
+    "node_modules/@types/aws-serverless-express": {
+      "version": "3.3.10",
+      "resolved": "https://registry.npmjs.org/@types/aws-serverless-express/-/aws-serverless-express-3.3.10.tgz",
+      "integrity": "sha512-a/NGZQ9MDKX0PIXHgCa0L0fHbYTjvMJ9vKGr22PvkU1EBXSfnVNnNJgDmTLmMzrURqeHCS7uIIYZTawB1pPSrQ==",
+      "dependencies": {
+        "@types/aws-lambda": "*",
+        "@types/express": "*",
+        "@types/node": "*"
+      }
+    },
+    "node_modules/@types/body-parser": {
+      "version": "1.19.5",
+      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.5.tgz",
+      "integrity": "sha512-fB3Zu92ucau0iQ0JMCFQE7b/dv8Ot07NI3KaZIkIUNXq82k4eBAqUaneXfleGY9JWskeS9y+u0nXMyspcuQrCg==",
+      "dependencies": {
+        "@types/connect": "*",
+        "@types/node": "*"
+      }
+    },
+    "node_modules/@types/connect": {
+      "version": "3.4.38",
+      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.38.tgz",
+      "integrity": "sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==",
+      "dependencies": {
+        "@types/node": "*"
+      }
+    },
+    "node_modules/@types/express": {
+      "version": "5.0.1",
+      "resolved": "https://registry.npmjs.org/@types/express/-/express-5.0.1.tgz",
+      "integrity": "sha512-UZUw8vjpWFXuDnjFTh7/5c2TWDlQqeXHi6hcN7F2XSVT5P+WmUnnbFS3KA6Jnc6IsEqI2qCVu2bK0R0J4A8ZQQ==",
+      "dependencies": {
+        "@types/body-parser": "*",
+        "@types/express-serve-static-core": "^5.0.0",
+        "@types/serve-static": "*"
+      }
+    },
+    "node_modules/@types/express-serve-static-core": {
+      "version": "5.0.6",
+      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-5.0.6.tgz",
+      "integrity": "sha512-3xhRnjJPkULekpSzgtoNYYcTWgEZkp4myc+Saevii5JPnHNvHMRlBSHDbs7Bh1iPPoVTERHEZXyhyLbMEsExsA==",
+      "dependencies": {
+        "@types/node": "*",
+        "@types/qs": "*",
+        "@types/range-parser": "*",
+        "@types/send": "*"
+      }
+    },
+    "node_modules/@types/http-errors": {
+      "version": "2.0.4",
+      "resolved": "https://registry.npmjs.org/@types/http-errors/-/http-errors-2.0.4.tgz",
+      "integrity": "sha512-D0CFMMtydbJAegzOyHjtiKPLlvnm3iTZyZRSZoLq2mRhDdmLfIWOCYPfQJ4cu2erKghU++QvjcUjp/5h7hESpA=="
+    },
+    "node_modules/@types/mime": {
+      "version": "1.3.5",
+      "resolved": "https://registry.npmjs.org/@types/mime/-/mime-1.3.5.tgz",
+      "integrity": "sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w=="
+    },
+    "node_modules/@types/node": {
+      "version": "22.15.2",
+      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.2.tgz",
+      "integrity": "sha512-uKXqKN9beGoMdBfcaTY1ecwz6ctxuJAcUlwE55938g0ZJ8lRxwAZqRz2AJ4pzpt5dHdTPMB863UZ0ESiFUcP7A==",
+      "dependencies": {
+        "undici-types": "~6.21.0"
+      }
+    },
+    "node_modules/@types/qs": {
+      "version": "6.9.18",
+      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.9.18.tgz",
+      "integrity": "sha512-kK7dgTYDyGqS+e2Q4aK9X3D7q234CIZ1Bv0q/7Z5IwRDoADNU81xXJK/YVyLbLTZCoIwUoDoffFeF+p/eIklAA=="
+    },
+    "node_modules/@types/range-parser": {
+      "version": "1.2.7",
+      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.7.tgz",
+      "integrity": "sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ=="
+    },
+    "node_modules/@types/send": {
+      "version": "0.17.4",
+      "resolved": "https://registry.npmjs.org/@types/send/-/send-0.17.4.tgz",
+      "integrity": "sha512-x2EM6TJOybec7c52BX0ZspPodMsQUd5L6PRwOunVyVUhXiBSKf3AezDL8Dgvgt5o0UfKNfuA0eMLr2wLT4AiBA==",
+      "dependencies": {
+        "@types/mime": "^1",
+        "@types/node": "*"
+      }
+    },
+    "node_modules/@types/serve-static": {
+      "version": "1.15.7",
+      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.7.tgz",
+      "integrity": "sha512-W8Ym+h8nhuRwaKPaDw34QUkwsGi6Rc4yYqvKFo5rm2FUEhCFbzVWrxXUxuKK8TASjWsysJY0nsmNCGhCOIsrOw==",
+      "dependencies": {
+        "@types/http-errors": "*",
+        "@types/node": "*",
+        "@types/send": "*"
+      }
     },
     "node_modules/@types/uuid": {
       "version": "9.0.8",
@@ -2483,6 +2578,11 @@
         "node": ">= 0.6"
       }
     },
+    "node_modules/undici-types": {
+      "version": "6.21.0",
+      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
+      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ=="
+    },
     "node_modules/unpipe": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
diff --git c/amplify/backend/function/predictionsLambda/src/package.json i/amplify/backend/function/predictionsLambda/package.json
similarity index 92%
rename from amplify/backend/function/predictionsLambda/src/package.json
rename to amplify/backend/function/predictionsLambda/package.json
index 9498310..5405478 100644
--- c/amplify/backend/function/predictionsLambda/src/package.json
+++ i/amplify/backend/function/predictionsLambda/package.json
@@ -5,6 +5,7 @@
   "main": "index.js",
   "license": "Apache-2.0",
   "dependencies": {
+    "@types/aws-serverless-express": "^3.3.10",
     "aws-serverless-express": "^3.3.5",
     "axios": "^1.8.4",
     "body-parser": "^1.19.1",
diff --git c/amplify/backend/function/predictionsLambda/src/app.js i/amplify/backend/function/predictionsLambda/src/app.js
index de4d4a3..c03f27d 100644
--- c/amplify/backend/function/predictionsLambda/src/app.js
+++ i/amplify/backend/function/predictionsLambda/src/app.js
@@ -1,3 +1,4 @@
+"use strict";
 /*
 Copyright 2017 - 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with the License. A copy of the License is located at
@@ -5,140 +6,126 @@ Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and limitations under the License.
 */
-
-const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
-const { DynamoDBDocumentClient, GetCommand } = require("@aws-sdk/lib-dynamodb");
-const awsServerlessExpressMiddleware = require("aws-serverless-express/middleware");
-const bodyParser = require("body-parser");
-const express = require("express");
-const ddbClient = new DynamoDBClient({ region: process.env.TABLE_REGION });
-const ddbDocClient = DynamoDBDocumentClient.from(ddbClient, {
-  convertClassInstanceToMap: true,
-});
-
-const { Prediction, PredictionAlreadyClosed } = require("./models/prediction");
-const { fetchBitcoinPrice } = require("./utils/fetchBitcoinPrice.js");
-const {
-  schedulePredictionClosing,
-} = require("./utils/schedulePredictionClosing");
-const {
-  User,
-  UserNotFound,
-  PredictionInProgress,
-  InvalidDirection,
-} = require("./models/user");
-
-let tableName = "usersTable";
-if (process.env.ENV && process.env.ENV !== "NONE") {
-  tableName = tableName + "-" + process.env.ENV;
-}
-
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.app = void 0;
+const middleware_1 = __importDefault(require("aws-serverless-express/middleware"));
+const body_parser_1 = __importDefault(require("body-parser"));
+const express_1 = __importDefault(require("express"));
+const prediction_1 = require("./models/prediction");
+const fetchBitcoinPrice_js_1 = require("./utils/fetchBitcoinPrice.js");
+const schedulePredictionClosing_1 = require("./utils/schedulePredictionClosing");
+const user_1 = require("./models/user");
 const path = "/predictions";
-
 // declare a new express app
-const app = express();
-app.use(bodyParser.json());
-app.use(awsServerlessExpressMiddleware.eventContext());
-
+const app = (0, express_1.default)();
+exports.app = app;
+app.use(body_parser_1.default.json());
+app.use(middleware_1.default.eventContext());
 // Enable CORS for all methods
 app.use(function (req, res, next) {
-  res.header("Access-Control-Allow-Origin", "*");
-  res.header("Access-Control-Allow-Headers", "*");
-  next();
+    res.header("Access-Control-Allow-Origin", "*");
+    res.header("Access-Control-Allow-Headers", "*");
+    next();
 });
-
 /************************************
  * HTTP post method to place a prediction *
  *************************************/
-
 app.post(path + "/place", async function (req, res) {
-  try {
-    let user;
     try {
-      user = await User.findById(req.body.userId);
-    } catch (err) {
-      if (err instanceof UserNotFound) {
-        return res.status(404).json({ error: "User not found" });
-      }
-      throw err;
+        let user;
+        try {
+            user = await user_1.User.findById(req.body.userId);
+        }
+        catch (err) {
+            if (err instanceof user_1.UserNotFound) {
+                res.status(404).json({ error: "User not found" });
+                return;
+            }
+            throw err;
+        }
+        try {
+            const direction = req.body.direction;
+            const duration = req.body.duration
+                ? Number(req.body.duration)
+                : prediction_1.Prediction.DEFAULT_DURATION_IN_SECONDS;
+            const startPrice = await (0, fetchBitcoinPrice_js_1.fetchBitcoinPrice)();
+            // TODO: Wrap these two async functions with Promise.all and rollback
+            // completed action if other one fails
+            await user.predict(startPrice, direction, duration);
+            console.log("user :", user);
+            const lastPredictionId = user.getLastPrediction().id;
+            await (0, schedulePredictionClosing_1.schedulePredictionClosing)(user.id, lastPredictionId, duration);
+            res.status(200).json(user);
+            return;
+        }
+        catch (err) {
+            if (err instanceof user_1.PredictionInProgress) {
+                res.status(400).json({ error: "A prediction is already in progress" });
+                return;
+            }
+            else if (err instanceof user_1.InvalidDirection) {
+                res.status(400).json({ error: "Invalid direction provided" });
+                return;
+            }
+            else {
+                throw err;
+            }
+        }
     }
-
-    try {
-      const direction = req.body.direction;
-      const duration = req.body.duration
-        ? Number(req.body.duration)
-        : Prediction.DEFAULT_DURATION_IN_SECONDS;
-      const startPrice = await fetchBitcoinPrice();
-
-      // TODO: Wrap these two async functions with Promise.all and rollback
-      // completed action if other one fails
-      await user.predict(startPrice, direction, duration);
-      const lastPredictionId = user.getLastPrediction().id;
-      await schedulePredictionClosing(user.id, lastPredictionId, duration);
-
-      return res.status(200).json(user);
-    } catch (err) {
-      if (err instanceof PredictionInProgress) {
-        return res
-          .status(400)
-          .json({ error: "A prediction is already in progress" });
-      } else if (err instanceof InvalidDirection) {
-        return res.status(400).json({ error: "Invalid direction provided" });
-      } else {
-        throw err;
-      }
+    catch (err) {
+        console.error(err);
+        res.status(500).json({ error: "Internal server error" });
+        return;
     }
-  } catch (err) {
-    console.error(err);
-    return res.status(500).json({ error: "Internal server error" });
-  }
 });
-
 /************************************
  * HTTP post method to close a prediction *
  *************************************/
-
 app.post(path + "/close", async function (req, res) {
-  try {
-    let user;
     try {
-      user = await User.findById(req.body.userId);
-    } catch (err) {
-      if (err instanceof UserNotFound) {
-        return res.status(404).json({ error: "User not found" });
-      }
-      throw err;
+        let user;
+        try {
+            user = await user_1.User.findById(req.body.userId);
+        }
+        catch (err) {
+            if (err instanceof user_1.UserNotFound) {
+                res.status(404).json({ error: "User not found" });
+                return;
+            }
+            throw err;
+        }
+        try {
+            const finalPrice = await (0, fetchBitcoinPrice_js_1.fetchBitcoinPrice)();
+            const lastPrediction = user.getLastPrediction().close(finalPrice);
+            await user.closeLastPrediction(lastPrediction);
+            res.status(200).json(user);
+            return;
+        }
+        catch (err) {
+            if (err instanceof prediction_1.PredictionAlreadyClosed) {
+                res
+                    .status(422)
+                    .json({ error: "That prediction has already finished." });
+                return;
+            }
+            else if (err instanceof user_1.InvalidDirection) {
+                res.status(400).json({ error: "Invalid direction provided" });
+                return;
+            }
+            else {
+                throw err;
+            }
+        }
     }
-
-    try {
-      const finalPrice = await fetchBitcoinPrice();
-      const lastPrediction = user.getLastPrediction().close(finalPrice);
-
-      await user.closeLastPrediction(lastPrediction);
-
-      return res.status(200).json(user);
-    } catch (err) {
-      if (err instanceof PredictionAlreadyClosed) {
-        return res
-          .status(422)
-          .json({ error: "That prediction has already finished." });
-      } else if (err instanceof InvalidDirection) {
-        return res.status(400).json({ error: "Invalid direction provided" });
-      } else {
-        throw err;
-      }
+    catch (err) {
+        console.error(err);
+        res.status(500).json({ error: "Internal server error" });
+        return;
     }
-  } catch (err) {
-    console.error(err);
-    return res.status(500).json({ error: "Internal server error" });
-  }
 });
-
 app.listen(3000, function () {
-  console.log("App started");
+    console.log("App started");
 });
-
-// Export the app object. When executing the application local this does nothing. However,
-// to port it to AWS Lambda we will create a wrapper around that will load the app from
-// this file
-module.exports = app;
diff --git c/amplify/backend/function/predictionsLambda/src/index.js i/amplify/backend/function/predictionsLambda/src/index.js
index 832a7f6..b810418 100644
--- c/amplify/backend/function/predictionsLambda/src/index.js
+++ i/amplify/backend/function/predictionsLambda/src/index.js
@@ -1,15 +1,14 @@
-const awsServerlessExpress = require('aws-serverless-express');
-const app = require('./app');
-
-/**
- * @type {import('http').Server}
- */
-const server = awsServerlessExpress.createServer(app);
-
-/**
- * @type {import('@types/aws-lambda').APIGatewayProxyHandler}
- */
-exports.handler = (event, context) => {
-  console.log(`EVENT: ${JSON.stringify(event)}`);
-  return awsServerlessExpress.proxy(server, event, context, 'PROMISE').promise;
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
 };
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.handler = void 0;
+const aws_serverless_express_1 = __importDefault(require("aws-serverless-express"));
+const app_1 = require("./app");
+const server = aws_serverless_express_1.default.createServer(app_1.app);
+const handler = async (event, context) => {
+    console.log(`EVENT: ${JSON.stringify(event)}`);
+    return aws_serverless_express_1.default.proxy(server, event, context, "PROMISE").promise;
+};
+exports.handler = handler;
diff --git c/amplify/backend/function/predictionsLambda/src/models/prediction.js i/amplify/backend/function/predictionsLambda/src/models/prediction.js
index 98a8299..c790130 100644
--- c/amplify/backend/function/predictionsLambda/src/models/prediction.js
+++ i/amplify/backend/function/predictionsLambda/src/models/prediction.js
@@ -1,64 +1,56 @@
-const crypto = require("crypto");
-
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.Prediction = exports.PredictionAlreadyClosed = void 0;
+const crypto_1 = __importDefault(require("crypto"));
 class PredictionAlreadyClosed extends Error {
-  constructor(message) {
-    super(message);
-    this.name = "PredictionAlreadyClosed";
-  }
-}
-
-class Prediction {
-  // default prediction duration is 60 seconds
-  static DEFAULT_DURATION_IN_SECONDS = 60;
-  static DIRECTIONS = { UP: "up", DOWN: "down" };
-  static STATUSES = { WON: "won", LOST: "lost" };
-
-  constructor({
-    id,
-    direction,
-    startPrice,
-    startTime,
-    finishTime,
-    finalPrice,
-    status,
-  }) {
-    this.id = id || crypto.randomUUID();
-    this.direction = direction;
-    this.startTime = startTime;
-    this.finishTime = finishTime;
-    this.startPrice = startPrice;
-    this.finalPrice = finalPrice || null;
-    this.status = status || null;
-  }
-
-  close(finalPrice) {
-    if (this.finalPrice) {
-      throw new PredictionAlreadyClosed();
+    constructor(message) {
+        super(message);
+        this.name = "PredictionAlreadyClosed";
     }
-
-    this.finalPrice = finalPrice;
-
-    (this.finalPrice > this.startPrice &&
-      this.direction == this.constructor.DIRECTIONS.UP) ||
-    (this.startPrice > this.finalPrice &&
-      this.direction == this.constructor.DIRECTIONS.DOWN)
-      ? (this.status = this.constructor.STATUSES.WON)
-      : (this.status = this.constructor.STATUSES.LOST);
-
-    return this;
-  }
-
-  toJSON() {
-    return {
-      direction: this.direction,
-      startPrice: this.startPrice,
-      startTime: this.startTime,
-      finishTime: this.finishTime,
-      finalPrice: this.finalPrice,
-      status: this.status,
-      id: this.id,
-    };
-  }
 }
-
-module.exports = { Prediction, PredictionAlreadyClosed };
+exports.PredictionAlreadyClosed = PredictionAlreadyClosed;
+class Prediction {
+    constructor({ id, direction, startPrice, finalPrice, startTime, finishTime, status, }) {
+        this.id = id ?? crypto_1.default.randomUUID();
+        this.direction = direction;
+        this.startTime = startTime;
+        this.finishTime = finishTime;
+        this.startPrice = startPrice;
+        this.finalPrice = finalPrice ?? null;
+        this.status = status ?? null;
+    }
+    close(finalPrice) {
+        if (this.finalPrice)
+            throw new PredictionAlreadyClosed();
+        this.finalPrice = finalPrice;
+        if (this.isWinningResult(this.startPrice, this.finalPrice, this.direction)) {
+            this.status = Prediction.STATUSES.WON;
+        }
+        else {
+            this.status = Prediction.STATUSES.LOST;
+        }
+        return this;
+    }
+    toJSON() {
+        return {
+            direction: this.direction,
+            startPrice: this.startPrice,
+            startTime: this.startTime,
+            finishTime: this.finishTime,
+            finalPrice: this.finalPrice,
+            status: this.status,
+            id: this.id,
+        };
+    }
+    isWinningResult(startPrice, finalPrice, direction) {
+        return ((finalPrice > startPrice && direction == Prediction.DIRECTIONS.UP) ||
+            (startPrice > finalPrice && direction == Prediction.DIRECTIONS.DOWN));
+    }
+}
+exports.Prediction = Prediction;
+Prediction.DEFAULT_DURATION_IN_SECONDS = 60;
+Prediction.DIRECTIONS = { UP: "up", DOWN: "down" };
+Prediction.STATUSES = { WON: "won", LOST: "lost" };
diff --git c/amplify/backend/function/predictionsLambda/src/models/user.js i/amplify/backend/function/predictionsLambda/src/models/user.js
index c55a6a9..4273c2a 100644
--- c/amplify/backend/function/predictionsLambda/src/models/user.js
+++ i/amplify/backend/function/predictionsLambda/src/models/user.js
@@ -1,131 +1,110 @@
-const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
-const {
-  DynamoDBDocumentClient,
-  GetCommand,
-  PutCommand,
-} = require("@aws-sdk/lib-dynamodb");
-
-const ddbClient = new DynamoDBClient({ region: process.env.REGION });
-const ddbDocClient = DynamoDBDocumentClient.from(ddbClient, {
-  convertClassInstanceToMap: true,
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.InvalidDirection = exports.PredictionInProgress = exports.UserNotFound = exports.User = void 0;
+const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
+const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
+const prediction_1 = require("./prediction");
+const ddbClient = new client_dynamodb_1.DynamoDBClient({ region: process.env.REGION });
+const ddbDocClient = lib_dynamodb_1.DynamoDBDocumentClient.from(ddbClient, {
+    marshallOptions: { convertClassInstanceToMap: true },
 });
-
 let tableName = "usersTable";
 if (process.env.ENV && process.env.ENV !== "NONE") {
-  tableName = tableName + "-" + process.env.ENV;
+    tableName = tableName + "-" + process.env.ENV;
 }
-
-const { Prediction } = require("./prediction");
-
 class UserNotFound extends Error {
-  constructor(message) {
-    super(message);
-    this.name = "UserNotFound";
-  }
+    constructor(message) {
+        super(message);
+        this.name = "UserNotFound";
+    }
 }
-
+exports.UserNotFound = UserNotFound;
 class PredictionInProgress extends Error {
-  constructor(message) {
-    super(message);
-    this.name = "PredictionInProgress";
-  }
+    constructor(message) {
+        super(message);
+        this.name = "PredictionInProgress";
+    }
 }
-
+exports.PredictionInProgress = PredictionInProgress;
 class InvalidDirection extends Error {
-  constructor(message) {
-    super(message);
-    this.name = "InvalidDirection";
-  }
+    constructor(message) {
+        super(message);
+        this.name = "InvalidDirection";
+    }
 }
-
+exports.InvalidDirection = InvalidDirection;
 class User {
-  constructor(data = {}) {
-    this.id = data.id || null;
-    this.predictions = Array.isArray(data.predictions) ? data.predictions : [];
-    this.score = data.score || 0;
-
-    // TODO: Use an ORM or something here.
-    for (const key in data) {
-      if (!this.hasOwnProperty(key)) {
-        this[key] = data[key];
-      }
+    constructor(id, predictions, score) {
+        this.id = id;
+        this.predictions = predictions;
+        this.score = score;
+        this.id = id || null;
+        this.predictions = predictions;
+        this.score = score ?? 0;
     }
-  }
-
-  getLastPrediction() {
-    return new Prediction(this.predictions[this.predictions.length - 1]);
-  }
-
-  async closeLastPrediction(prediction) {
-    prediction.status == Prediction.STATUSES.WON ? this.score++ : this.score--;
-
-    this.predictions[this.predictions.length - 1] = prediction.toJSON();
-
-    return await this.save();
-  }
-
-  static async findById(id) {
-    const params = {
-      TableName: tableName,
-      Key: { id },
-    };
-
-    try {
-      const { Item } = await ddbDocClient.send(new GetCommand(params));
-      if (!Item) throw new UserNotFound();
-      return new User(Item);
-    } catch (error) {
-      console.error("Error finding user:", error);
-      throw error;
+    getLastPrediction() {
+        return new prediction_1.Prediction(this.predictions[this.predictions.length - 1]);
     }
-  }
-
-  async predict(startPrice, direction, duration) {
-    // If any of the user's predictions don't have a final price, don't allow a new prediction.
-    if (this.predictions.some((prediction) => !prediction.finalPrice)) {
-      throw new PredictionInProgress();
+    async closeLastPrediction(prediction) {
+        if (prediction.status == prediction_1.Prediction.STATUSES.WON) {
+            this.score++;
+        }
+        else {
+            this.score--;
+        }
+        this.predictions[this.predictions.length - 1] = prediction;
+        return await this.save();
     }
-
-    // TODO: Move this logic to Prediction class
-    if (!Object.values(Prediction.DIRECTIONS).includes(direction)) {
-      throw new InvalidDirection();
+    static async findById(id) {
+        const params = {
+            TableName: tableName,
+            Key: { id },
+        };
+        try {
+            const { Item } = await ddbDocClient.send(new lib_dynamodb_1.GetCommand(params));
+            if (!Item)
+                throw new UserNotFound();
+            return new User(Item.id, Item.predictions, Item.score);
+        }
+        catch (error) {
+            console.error("Error finding user:", error);
+            throw error;
+        }
     }
-
-    const startTime = Date.now();
-    const finishTime =
-      startTime + (duration || Prediction.DEFAULT_DURATION_IN_SECONDS) * 1000;
-
-    const newPrediction = new Prediction({
-      direction,
-      startPrice,
-      startTime,
-      finishTime,
-    });
-
-    this.predictions.push(newPrediction.toJSON());
-    console.log(this);
-    return await this.save();
-  }
-
-  async save() {
-    const params = {
-      TableName: tableName,
-      Item: { ...this },
-    };
-
-    try {
-      await ddbDocClient.send(new PutCommand(params));
-      return this;
-    } catch (error) {
-      console.error("Error saving user:", error);
-      throw error;
+    async predict(startPrice, direction, duration) {
+        // If any of the user's predictions don't have a final price, don't allow a new prediction.
+        if (this.predictions.some((prediction) => !prediction.finalPrice)) {
+            throw new PredictionInProgress();
+        }
+        // TODO: Move this logic to Prediction class
+        if (!Object.values(prediction_1.Prediction.DIRECTIONS).includes(direction)) {
+            throw new InvalidDirection();
+        }
+        const startTime = Date.now();
+        const finishTime = startTime + (duration || prediction_1.Prediction.DEFAULT_DURATION_IN_SECONDS) * 1000;
+        const newPrediction = new prediction_1.Prediction({
+            direction: direction,
+            startPrice: startPrice,
+            startTime: startTime,
+            finishTime: finishTime,
+        });
+        this.predictions.push(newPrediction);
+        console.log(this);
+        return await this.save();
+    }
+    async save() {
+        const params = {
+            TableName: tableName,
+            Item: { ...this },
+        };
+        try {
+            await ddbDocClient.send(new lib_dynamodb_1.PutCommand(params));
+            return this;
+        }
+        catch (error) {
+            console.error("Error saving user:", error);
+            throw error;
+        }
     }
-  }
 }
-
-module.exports = {
-  User,
-  UserNotFound,
-  PredictionInProgress,
-  InvalidDirection,
-};
+exports.User = User;
diff --git c/amplify/backend/function/predictionsLambda/src/utils/fetchBitcoinPrice.js i/amplify/backend/function/predictionsLambda/src/utils/fetchBitcoinPrice.js
index 4512613..a6aaf70 100644
--- c/amplify/backend/function/predictionsLambda/src/utils/fetchBitcoinPrice.js
+++ i/amplify/backend/function/predictionsLambda/src/utils/fetchBitcoinPrice.js
@@ -1,20 +1,20 @@
-const axios = require("axios");
-
-async function fetchBitcoinPrice() {
-  const API_URL = "https://okx.com/api/v5/market/ticker?instId=BTC-USD-SWAP";
-
-  try {
-    const response = await axios.get(API_URL);
-
-    const bitcoinPriceInCents = Math.round(
-      Number.parseFloat(response.data.data[0].last, 10) * 100,
-    );
-
-    return bitcoinPriceInCents;
-  } catch (err) {
-    console.error("Error fetching Bitcoin price:", err);
-    throw err;
-  }
-}
-
-module.exports = { fetchBitcoinPrice };
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.fetchBitcoinPrice = void 0;
+const axios_1 = __importDefault(require("axios"));
+const fetchBitcoinPrice = async () => {
+    const API_URL = "https://okx.com/api/v5/market/ticker?instId=BTC-USD-SWAP";
+    try {
+        const response = await axios_1.default.get(API_URL);
+        const bitcoinPriceInCents = Math.round(Number.parseFloat(response.data.data[0].last) * 100);
+        return bitcoinPriceInCents;
+    }
+    catch (err) {
+        console.error("Error fetching Bitcoin price:", err);
+        throw err;
+    }
+};
+exports.fetchBitcoinPrice = fetchBitcoinPrice;
diff --git c/amplify/backend/function/predictionsLambda/src/utils/schedulePredictionClosing.js i/amplify/backend/function/predictionsLambda/src/utils/schedulePredictionClosing.js
index f9da327..cdd9679 100644
--- c/amplify/backend/function/predictionsLambda/src/utils/schedulePredictionClosing.js
+++ i/amplify/backend/function/predictionsLambda/src/utils/schedulePredictionClosing.js
@@ -1,31 +1,28 @@
-const { SFNClient, StartExecutionCommand } = require("@aws-sdk/client-sfn");
-
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.schedulePredictionClosing = void 0;
+const client_sfn_1 = require("@aws-sdk/client-sfn");
 // TODO: Fix hardcoded url and arns to handle other envs (staging/prod/etc)
 // TODO: Set retry behavior
-async function schedulePredictionClosing(userId, predictionId, duration) {
-  const response = await new SFNClient().send(
-    new StartExecutionCommand({
-      stateMachineArn:
-        "arn:aws:states:eu-north-1:393809552328:stateMachine:predictionStateMachine",
-      name: `close-prediction-${predictionId}`,
-      input: JSON.stringify({
-        waitSeconds: duration,
-        apiDetails: {
-          url: "https://8f3eziiwfh.execute-api.eu-north-1.amazonaws.com/dev/predictions/close",
-          method: "POST",
-          headers: {
-            "Content-Type": "application/json",
-          },
-          body: {
-            timestamp: new Date().toISOString(),
-            userId: userId,
-          },
-        },
-      }),
-    }),
-  );
-
-  return response;
-}
-
-module.exports = { schedulePredictionClosing };
+const schedulePredictionClosing = async (userId, predictionId, duration) => {
+    const response = await new client_sfn_1.SFNClient().send(new client_sfn_1.StartExecutionCommand({
+        stateMachineArn: "arn:aws:states:eu-north-1:393809552328:stateMachine:predictionStateMachine",
+        name: `close-prediction-${predictionId}`,
+        input: JSON.stringify({
+            waitSeconds: duration,
+            apiDetails: {
+                url: "https://8f3eziiwfh.execute-api.eu-north-1.amazonaws.com/dev/predictions/close",
+                method: "POST",
+                headers: {
+                    "Content-Type": "application/json",
+                },
+                body: {
+                    timestamp: new Date().toISOString(),
+                    userId: userId,
+                },
+            },
+        }),
+    }));
+    return response;
+};
+exports.schedulePredictionClosing = schedulePredictionClosing;
diff --git c/amplify/backend/function/predictionsLambda/tsconfig.json i/amplify/backend/function/predictionsLambda/tsconfig.json
new file mode 100644
index 0000000..ceff06a
--- /dev/null
+++ i/amplify/backend/function/predictionsLambda/tsconfig.json
@@ -0,0 +1,7 @@
+{
+  "extends": "../tsconfig",
+  "compilerOptions": {
+    "outDir": "./src"
+  },
+  "include": ["lib"]
+}
diff --git c/amplify/backend/function/tsconfig.json i/amplify/backend/function/tsconfig.json
new file mode 100644
index 0000000..e798268
--- /dev/null
+++ i/amplify/backend/function/tsconfig.json
@@ -0,0 +1,14 @@
+{
+  "$schema": "https://json.schemastore.org/tsconfig",
+  "display": "Amplify Lambda",
+  "compilerOptions": {
+    "target": "es2020",
+    "allowSyntheticDefaultImports": true,
+    "lib": ["dom", "esnext"],
+    "module": "commonjs",
+    "moduleResolution": "node",
+    "skipLibCheck": true,
+    "resolveJsonModule": true,
+    "esModuleInterop": true
+  }
+}
diff --git c/amplify/backend/function/usersLambda/src/event-create.json i/amplify/backend/function/usersLambda/event-create.json
similarity index 100%
rename from amplify/backend/function/usersLambda/src/event-create.json
rename to amplify/backend/function/usersLambda/event-create.json
diff --git c/amplify/backend/function/usersLambda/src/event-fetch.json i/amplify/backend/function/usersLambda/event-fetch.json
similarity index 100%
rename from amplify/backend/function/usersLambda/src/event-fetch.json
rename to amplify/backend/function/usersLambda/event-fetch.json
diff --git c/amplify/backend/function/usersLambda/lib/app.ts i/amplify/backend/function/usersLambda/lib/app.ts
new file mode 100644
index 0000000..6035113
--- /dev/null
+++ i/amplify/backend/function/usersLambda/lib/app.ts
@@ -0,0 +1,93 @@
+import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
+import {
+  DynamoDBDocumentClient,
+  GetCommand,
+  PutCommand,
+} from "@aws-sdk/lib-dynamodb";
+import awsServerlessExpressMiddleware from "aws-serverless-express/middleware";
+import bodyParser from "body-parser";
+import express, { Request, Response } from "express";
+
+const ddbClient = new DynamoDBClient({
+  region: process.env.TABLE_REGION,
+});
+const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
+
+let tableName = "usersTable";
+if (process.env.ENV && process.env.ENV !== "NONE") {
+  tableName = tableName + "-" + process.env.ENV;
+}
+
+const path = "/users";
+
+const app = express();
+app.use(bodyParser.json());
+app.use(awsServerlessExpressMiddleware.eventContext());
+
+app.use(function (req, res, next) {
+  res.header("Access-Control-Allow-Origin", "*");
+  res.header("Access-Control-Allow-Headers", "*");
+  next();
+});
+
+/*****************************************
+ * HTTP Get method to retrieve single user *
+ *****************************************/
+
+// TODO: Refactor with User.findById() for fetching User
+app.get(path + "/:id", async (req: Request, res: Response) => {
+  const userId = req.params.id;
+
+  const getItemParams = {
+    TableName: tableName,
+    Key: {
+      id: userId,
+    },
+  };
+
+  try {
+    const { Item } = await ddbDocClient.send(new GetCommand(getItemParams));
+
+    if (Item) {
+      res.status(200).json(Item);
+    } else {
+      res.status(404).json({ error: "User not found" });
+    }
+  } catch (err) {
+    console.error(err);
+    res.status(500).json({ error: "Internal server error" });
+  }
+});
+
+/************************************
+ * HTTP post method for creating a user *
+ *************************************/
+
+// TODO: The logic for new user defaults should belong in the User class
+app.post(path, async function (req: Request, res: Response) {
+  const userId = crypto.randomUUID();
+  const putItemParams = {
+    TableName: tableName,
+    Item: {
+      id: userId,
+      score: 0,
+      predictions: [],
+    },
+  };
+  try {
+    await ddbDocClient.send(new PutCommand(putItemParams));
+    res.status(200).json({ id: userId, score: 0, predictions: [] });
+  } catch (err) {
+    console.error(err);
+    res.status(500).json({ error: "Internal server error" });
+  }
+});
+
+app.listen(3000, function () {
+  console.log("App started");
+});
+
+// Export the app object. When executing the application local this does nothing. However,
+// to port it to AWS Lambda we will create a wrapper around that will load the app from
+// this file
+export { app };
diff --git c/amplify/backend/function/usersLambda/lib/index.ts i/amplify/backend/function/usersLambda/lib/index.ts
new file mode 100644
index 0000000..e0287ef
--- /dev/null
+++ i/amplify/backend/function/usersLambda/lib/index.ts
@@ -0,0 +1,17 @@
+import {
+  APIGatewayProxyEvent,
+  APIGatewayProxyResult,
+  Context,
+} from "aws-lambda";
+import awsServerlessExpress from "aws-serverless-express";
+import { app } from "./app";
+
+const server = awsServerlessExpress.createServer(app);
+
+export const handler = async (
+  event: APIGatewayProxyEvent,
+  context: Context,
+): Promise<APIGatewayProxyResult> => {
+  console.log(`EVENT: ${JSON.stringify(event)}`);
+  return awsServerlessExpress.proxy(server, event, context, "PROMISE").promise;
+};
diff --git c/amplify/backend/function/usersLambda/src/package-lock.json i/amplify/backend/function/usersLambda/package-lock.json
similarity index 95%
rename from amplify/backend/function/usersLambda/src/package-lock.json
rename to amplify/backend/function/usersLambda/package-lock.json
index dec8f0c..3ffdfbe 100644
--- c/amplify/backend/function/usersLambda/src/package-lock.json
+++ i/amplify/backend/function/usersLambda/package-lock.json
@@ -9,6 +9,7 @@
       "version": "1.0.0",
       "license": "Apache-2.0",
       "dependencies": {
+        "@types/aws-serverless-express": "^3.3.10",
         "aws-serverless-express": "^3.3.5",
         "body-parser": "^1.19.1",
         "express": "^4.17.2"
@@ -18,7 +19,8 @@
         "@aws-sdk/lib-dynamodb": "^3.188.0",
         "@aws-sdk/smithy-client": "^3.188.0",
         "@aws-sdk/types": "^3.188.0",
-        "@types/aws-lambda": "^8.10.92"
+        "@types/aws-lambda": "^8.10.92",
+        "@types/express": "^4.17.21"
       }
     },
     "node_modules/@aws-crypto/sha256-browser": {
@@ -1504,8 +1506,103 @@
     "node_modules/@types/aws-lambda": {
       "version": "8.10.149",
       "resolved": "https://registry.npmjs.org/@types/aws-lambda/-/aws-lambda-8.10.149.tgz",
-      "integrity": "sha512-NXSZIhfJjnXqJgtS7IwutqIF/SOy1Wz5Px4gUY1RWITp3AYTyuJS4xaXr/bIJY1v15XMzrJ5soGnPM+7uigZjA==",
-      "dev": true
+      "integrity": "sha512-NXSZIhfJjnXqJgtS7IwutqIF/SOy1Wz5Px4gUY1RWITp3AYTyuJS4xaXr/bIJY1v15XMzrJ5soGnPM+7uigZjA=="
+    },
+    "node_modules/@types/aws-serverless-express": {
+      "version": "3.3.10",
+      "resolved": "https://registry.npmjs.org/@types/aws-serverless-express/-/aws-serverless-express-3.3.10.tgz",
+      "integrity": "sha512-a/NGZQ9MDKX0PIXHgCa0L0fHbYTjvMJ9vKGr22PvkU1EBXSfnVNnNJgDmTLmMzrURqeHCS7uIIYZTawB1pPSrQ==",
+      "dependencies": {
+        "@types/aws-lambda": "*",
+        "@types/express": "*",
+        "@types/node": "*"
+      }
+    },
+    "node_modules/@types/body-parser": {
+      "version": "1.19.5",
+      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.5.tgz",
+      "integrity": "sha512-fB3Zu92ucau0iQ0JMCFQE7b/dv8Ot07NI3KaZIkIUNXq82k4eBAqUaneXfleGY9JWskeS9y+u0nXMyspcuQrCg==",
+      "dependencies": {
+        "@types/connect": "*",
+        "@types/node": "*"
+      }
+    },
+    "node_modules/@types/connect": {
+      "version": "3.4.38",
+      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.38.tgz",
+      "integrity": "sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==",
+      "dependencies": {
+        "@types/node": "*"
+      }
+    },
+    "node_modules/@types/express": {
+      "version": "4.17.21",
+      "resolved": "https://registry.npmjs.org/@types/express/-/express-4.17.21.tgz",
+      "integrity": "sha512-ejlPM315qwLpaQlQDTjPdsUFSc6ZsP4AN6AlWnogPjQ7CVi7PYF3YVz+CY3jE2pwYf7E/7HlDAN0rV2GxTG0HQ==",
+      "dependencies": {
+        "@types/body-parser": "*",
+        "@types/express-serve-static-core": "^4.17.33",
+        "@types/qs": "*",
+        "@types/serve-static": "*"
+      }
+    },
+    "node_modules/@types/express-serve-static-core": {
+      "version": "4.19.6",
+      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-4.19.6.tgz",
+      "integrity": "sha512-N4LZ2xG7DatVqhCZzOGb1Yi5lMbXSZcmdLDe9EzSndPV2HpWYWzRbaerl2n27irrm94EPpprqa8KpskPT085+A==",
+      "dependencies": {
+        "@types/node": "*",
+        "@types/qs": "*",
+        "@types/range-parser": "*",
+        "@types/send": "*"
+      }
+    },
+    "node_modules/@types/http-errors": {
+      "version": "2.0.4",
+      "resolved": "https://registry.npmjs.org/@types/http-errors/-/http-errors-2.0.4.tgz",
+      "integrity": "sha512-D0CFMMtydbJAegzOyHjtiKPLlvnm3iTZyZRSZoLq2mRhDdmLfIWOCYPfQJ4cu2erKghU++QvjcUjp/5h7hESpA=="
+    },
+    "node_modules/@types/mime": {
+      "version": "1.3.5",
+      "resolved": "https://registry.npmjs.org/@types/mime/-/mime-1.3.5.tgz",
+      "integrity": "sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w=="
+    },
+    "node_modules/@types/node": {
+      "version": "22.15.2",
+      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.2.tgz",
+      "integrity": "sha512-uKXqKN9beGoMdBfcaTY1ecwz6ctxuJAcUlwE55938g0ZJ8lRxwAZqRz2AJ4pzpt5dHdTPMB863UZ0ESiFUcP7A==",
+      "dependencies": {
+        "undici-types": "~6.21.0"
+      }
+    },
+    "node_modules/@types/qs": {
+      "version": "6.9.18",
+      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.9.18.tgz",
+      "integrity": "sha512-kK7dgTYDyGqS+e2Q4aK9X3D7q234CIZ1Bv0q/7Z5IwRDoADNU81xXJK/YVyLbLTZCoIwUoDoffFeF+p/eIklAA=="
+    },
+    "node_modules/@types/range-parser": {
+      "version": "1.2.7",
+      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.7.tgz",
+      "integrity": "sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ=="
+    },
+    "node_modules/@types/send": {
+      "version": "0.17.4",
+      "resolved": "https://registry.npmjs.org/@types/send/-/send-0.17.4.tgz",
+      "integrity": "sha512-x2EM6TJOybec7c52BX0ZspPodMsQUd5L6PRwOunVyVUhXiBSKf3AezDL8Dgvgt5o0UfKNfuA0eMLr2wLT4AiBA==",
+      "dependencies": {
+        "@types/mime": "^1",
+        "@types/node": "*"
+      }
+    },
+    "node_modules/@types/serve-static": {
+      "version": "1.15.7",
+      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.7.tgz",
+      "integrity": "sha512-W8Ym+h8nhuRwaKPaDw34QUkwsGi6Rc4yYqvKFo5rm2FUEhCFbzVWrxXUxuKK8TASjWsysJY0nsmNCGhCOIsrOw==",
+      "dependencies": {
+        "@types/http-errors": "*",
+        "@types/node": "*",
+        "@types/send": "*"
+      }
     },
     "node_modules/@types/uuid": {
       "version": "9.0.8",
@@ -2329,6 +2426,11 @@
         "node": ">= 0.6"
       }
     },
+    "node_modules/undici-types": {
+      "version": "6.21.0",
+      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
+      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ=="
+    },
     "node_modules/unpipe": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
diff --git c/amplify/backend/function/usersLambda/src/package.json i/amplify/backend/function/usersLambda/package.json
similarity index 80%
rename from amplify/backend/function/usersLambda/src/package.json
rename to amplify/backend/function/usersLambda/package.json
index e04e090..729bb9f 100644
--- c/amplify/backend/function/usersLambda/src/package.json
+++ i/amplify/backend/function/usersLambda/package.json
@@ -5,15 +5,17 @@
   "main": "index.js",
   "license": "Apache-2.0",
   "dependencies": {
+    "@types/aws-serverless-express": "^3.3.10",
     "aws-serverless-express": "^3.3.5",
     "body-parser": "^1.19.1",
     "express": "^4.17.2"
   },
   "devDependencies": {
-    "@types/aws-lambda": "^8.10.92",
     "@aws-sdk/client-dynamodb": "^3.188.0",
     "@aws-sdk/lib-dynamodb": "^3.188.0",
     "@aws-sdk/smithy-client": "^3.188.0",
-    "@aws-sdk/types" : "^3.188.0"
+    "@aws-sdk/types": "^3.188.0",
+    "@types/aws-lambda": "^8.10.92",
+    "@types/express": "^4.17.21"
   }
 }
diff --git c/amplify/backend/function/usersLambda/src/app.js i/amplify/backend/function/usersLambda/src/app.js
index 26edd7e..5296b8b 100644
--- c/amplify/backend/function/usersLambda/src/app.js
+++ i/amplify/backend/function/usersLambda/src/app.js
@@ -1,101 +1,81 @@
-/*
-Copyright 2017 - 2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.
-Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with the License. A copy of the License is located at
-    http://aws.amazon.com/apache2.0/
-or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and limitations under the License.
-*/
-
-const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
-const {
-  DynamoDBDocumentClient,
-  GetCommand,
-  PutCommand,
-} = require("@aws-sdk/lib-dynamodb");
-const awsServerlessExpressMiddleware = require("aws-serverless-express/middleware");
-const bodyParser = require("body-parser");
-const express = require("express");
-
-const ddbClient = new DynamoDBClient({ region: process.env.TABLE_REGION });
-const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
-
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.app = void 0;
+const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
+const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
+const middleware_1 = __importDefault(require("aws-serverless-express/middleware"));
+const body_parser_1 = __importDefault(require("body-parser"));
+const express_1 = __importDefault(require("express"));
+const ddbClient = new client_dynamodb_1.DynamoDBClient({
+    region: process.env.TABLE_REGION,
+});
+const ddbDocClient = lib_dynamodb_1.DynamoDBDocumentClient.from(ddbClient);
 let tableName = "usersTable";
 if (process.env.ENV && process.env.ENV !== "NONE") {
-  tableName = tableName + "-" + process.env.ENV;
+    tableName = tableName + "-" + process.env.ENV;
 }
-
 const path = "/users";
-
-// declare a new express app
-const app = express();
-app.use(bodyParser.json());
-app.use(awsServerlessExpressMiddleware.eventContext());
-
-// Enable CORS for all methods
+const app = (0, express_1.default)();
+exports.app = app;
+app.use(body_parser_1.default.json());
+app.use(middleware_1.default.eventContext());
 app.use(function (req, res, next) {
-  res.header("Access-Control-Allow-Origin", "*");
-  res.header("Access-Control-Allow-Headers", "*");
-  next();
+    res.header("Access-Control-Allow-Origin", "*");
+    res.header("Access-Control-Allow-Headers", "*");
+    next();
 });
-
 /*****************************************
  * HTTP Get method to retrieve single user *
  *****************************************/
-
 // TODO: Refactor with User.findById() for fetching User
-app.get(path + "/:id", async function (req, res) {
-  const userId = req.params.id;
-
-  const getItemParams = {
-    TableName: tableName,
-    Key: {
-      id: userId,
-    },
-  };
-
-  try {
-    const { Item } = await ddbDocClient.send(new GetCommand(getItemParams));
-
-    if (Item) {
-      res.json(Item);
-    } else {
-      res.status(404).json({ error: "User not found" });
+app.get(path + "/:id", async (req, res) => {
+    const userId = req.params.id;
+    const getItemParams = {
+        TableName: tableName,
+        Key: {
+            id: userId,
+        },
+    };
+    try {
+        const { Item } = await ddbDocClient.send(new lib_dynamodb_1.GetCommand(getItemParams));
+        if (Item) {
+            res.status(200).json(Item);
+        }
+        else {
+            res.status(404).json({ error: "User not found" });
+        }
+    }
+    catch (err) {
+        console.error(err);
+        res.status(500).json({ error: "Internal server error" });
     }
-  } catch (err) {
-    console.error(err);
-    return res.status(500).json({ error: "Internal server error" });
-  }
 });
-
 /************************************
  * HTTP post method for creating a user *
  *************************************/
-
 // TODO: The logic for new user defaults should belong in the User class
 app.post(path, async function (req, res) {
-  const userId = crypto.randomUUID();
-  let putItemParams = {
-    TableName: tableName,
-    Item: {
-      id: userId,
-      score: 0,
-      predictions: [],
-    },
-  };
-  try {
-    await ddbDocClient.send(new PutCommand(putItemParams));
-    res.json({ id: userId });
-  } catch (err) {
-    console.error(err);
-    return res.status(500).json({ error: "Internal server error" });
-  }
+    const userId = crypto.randomUUID();
+    const putItemParams = {
+        TableName: tableName,
+        Item: {
+            id: userId,
+            score: 0,
+            predictions: [],
+        },
+    };
+    try {
+        await ddbDocClient.send(new lib_dynamodb_1.PutCommand(putItemParams));
+        res.status(200).json({ id: userId, score: 0, predictions: [] });
+    }
+    catch (err) {
+        console.error(err);
+        res.status(500).json({ error: "Internal server error" });
+    }
 });
-
 app.listen(3000, function () {
-  console.log("App started");
+    console.log("App started");
 });
-
-// Export the app object. When executing the application local this does nothing. However,
-// to port it to AWS Lambda we will create a wrapper around that will load the app from
-// this file
-module.exports = app;
diff --git c/amplify/backend/function/usersLambda/src/index.js i/amplify/backend/function/usersLambda/src/index.js
index 832a7f6..b810418 100644
--- c/amplify/backend/function/usersLambda/src/index.js
+++ i/amplify/backend/function/usersLambda/src/index.js
@@ -1,15 +1,14 @@
-const awsServerlessExpress = require('aws-serverless-express');
-const app = require('./app');
-
-/**
- * @type {import('http').Server}
- */
-const server = awsServerlessExpress.createServer(app);
-
-/**
- * @type {import('@types/aws-lambda').APIGatewayProxyHandler}
- */
-exports.handler = (event, context) => {
-  console.log(`EVENT: ${JSON.stringify(event)}`);
-  return awsServerlessExpress.proxy(server, event, context, 'PROMISE').promise;
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
 };
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.handler = void 0;
+const aws_serverless_express_1 = __importDefault(require("aws-serverless-express"));
+const app_1 = require("./app");
+const server = aws_serverless_express_1.default.createServer(app_1.app);
+const handler = async (event, context) => {
+    console.log(`EVENT: ${JSON.stringify(event)}`);
+    return aws_serverless_express_1.default.proxy(server, event, context, "PROMISE").promise;
+};
+exports.handler = handler;
diff --git c/amplify/backend/function/usersLambda/tsconfig.json i/amplify/backend/function/usersLambda/tsconfig.json
new file mode 100644
index 0000000..ceff06a
--- /dev/null
+++ i/amplify/backend/function/usersLambda/tsconfig.json
@@ -0,0 +1,7 @@
+{
+  "extends": "../tsconfig",
+  "compilerOptions": {
+    "outDir": "./src"
+  },
+  "include": ["lib"]
+}
diff --git c/amplify/package-lock.json i/amplify/package-lock.json
new file mode 100644
index 0000000..ce7049e
--- /dev/null
+++ i/amplify/package-lock.json
@@ -0,0 +1,25 @@
+{
+  "name": "amplify",
+  "lockfileVersion": 3,
+  "requires": true,
+  "packages": {
+    "": {
+      "devDependencies": {
+        "typescript": "^5.8.3"
+      }
+    },
+    "node_modules/typescript": {
+      "version": "5.8.3",
+      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.8.3.tgz",
+      "integrity": "sha512-p1diW6TqL9L07nNxvRMM7hMMw4c5XOo/1ibL4aAIGmSAt9slTE1Xgw5KWuof2uTOvCg9BY7ZRi+GaF+7sfgPeQ==",
+      "dev": true,
+      "bin": {
+        "tsc": "bin/tsc",
+        "tsserver": "bin/tsserver"
+      },
+      "engines": {
+        "node": ">=14.17"
+      }
+    }
+  }
+}
diff --git c/amplify/package.json i/amplify/package.json
index aead43d..0df7ad3 100644
--- c/amplify/package.json
+++ i/amplify/package.json
@@ -1,3 +1,6 @@
 {
-  "type": "module"
-}
\ No newline at end of file
+  "type": "module",
+  "devDependencies": {
+    "typescript": "^5.8.3"
+  }
+}
diff --git c/amplify/team-provider-info.json i/amplify/team-provider-info.json
index 357fd5a..6d5f640 100644
--- c/amplify/team-provider-info.json
+++ i/amplify/team-provider-info.json
@@ -16,11 +16,11 @@
       "function": {
         "usersLambda": {
           "deploymentBucketName": "amplify-predictabit-dev-3d03b-deployment",
-          "s3Key": "amplify-builds/usersLambda-6c654a77696f73723138-build.zip"
+          "s3Key": "amplify-builds/usersLambda-5934316a632f6f6f484d-build.zip"
         },
         "predictionsLambda": {
           "deploymentBucketName": "amplify-predictabit-dev-3d03b-deployment",
-          "s3Key": "amplify-builds/predictionsLambda-424a38525975324e6269-build.zip"
+          "s3Key": "amplify-builds/predictionsLambda-744f307239727352692b-build.zip"
         }
       },
       "storage": {
diff --git c/package.json i/package.json
index 43809ea..a9f404e 100644
--- c/package.json
+++ i/package.json
@@ -10,7 +10,9 @@
     "preview": "vite preview",
     "test": "vitest",
     "test:watch": "vitest --watch",
-    "test:coverage": "vitest run --coverage"
+    "test:coverage": "vitest run --coverage",
+    "amplify:usersLambda": "cd amplify/backend/function/usersLambda && tsc -p ./tsconfig.json && cd -",
+    "amplify:predictionsLambda": "cd amplify/backend/function/predictionsLambda && tsc -p ./tsconfig.json && cd -"
   },
   "dependencies": {
     "@aws-sdk/client-sfn": "^3.787.0",
